{"ast":null,"code":"// ag-grid-react v30.0.4\nimport { useEffect, useLayoutEffect, useRef, useState } from 'react';\nexport const useEffectOnce = effect => {\n  const effectFn = useRef(effect);\n  const destroyFn = useRef();\n  const effectCalled = useRef(false);\n  const rendered = useRef(false);\n  const [, setVal] = useState(0);\n  if (effectCalled.current) {\n    rendered.current = true;\n  }\n  useEffect(() => {\n    // only execute the effect first time around\n    if (!effectCalled.current) {\n      destroyFn.current = effectFn.current();\n      effectCalled.current = true;\n    }\n    // this forces one render after the effect is run\n    setVal(val => val + 1);\n    return () => {\n      // if the comp didn't render since the useEffect was called,\n      // we know it's the dummy React cycle\n      if (!rendered.current) {\n        return;\n      }\n      // otherwise this is not a dummy destroy, so call the destroy func\n      if (destroyFn.current) {\n        destroyFn.current();\n      }\n    };\n  }, []);\n};\nexport const useLayoutEffectOnce = effect => {\n  const effectFn = useRef(effect);\n  const destroyFn = useRef();\n  const effectCalled = useRef(false);\n  const rendered = useRef(false);\n  const [, setVal] = useState(0);\n  if (effectCalled.current) {\n    rendered.current = true;\n  }\n  useLayoutEffect(() => {\n    // only execute the effect first time around\n    if (!effectCalled.current) {\n      destroyFn.current = effectFn.current();\n      effectCalled.current = true;\n    }\n    // this forces one render after the effect is run\n    setVal(val => val + 1);\n    return () => {\n      // if the comp didn't render since the useEffect was called,\n      // we know it's the dummy React cycle\n      if (!rendered.current) {\n        return;\n      }\n      // otherwise this is not a dummy destroy, so call the destroy func\n      if (destroyFn.current) {\n        destroyFn.current();\n      }\n    };\n  }, []);\n};","map":{"version":3,"names":["useEffect","useLayoutEffect","useRef","useState","useEffectOnce","effect","effectFn","destroyFn","effectCalled","rendered","setVal","current","val","useLayoutEffectOnce"],"sources":["/home/vvdn/React-practice/hello/node_modules/ag-grid-react/lib/reactUi/useEffectOnce.mjs"],"sourcesContent":["// ag-grid-react v30.0.4\nimport { useEffect, useLayoutEffect, useRef, useState } from 'react';\nexport const useEffectOnce = (effect) => {\n    const effectFn = useRef(effect);\n    const destroyFn = useRef();\n    const effectCalled = useRef(false);\n    const rendered = useRef(false);\n    const [, setVal] = useState(0);\n    if (effectCalled.current) {\n        rendered.current = true;\n    }\n    useEffect(() => {\n        // only execute the effect first time around\n        if (!effectCalled.current) {\n            destroyFn.current = effectFn.current();\n            effectCalled.current = true;\n        }\n        // this forces one render after the effect is run\n        setVal((val) => val + 1);\n        return () => {\n            // if the comp didn't render since the useEffect was called,\n            // we know it's the dummy React cycle\n            if (!rendered.current) {\n                return;\n            }\n            // otherwise this is not a dummy destroy, so call the destroy func\n            if (destroyFn.current) {\n                destroyFn.current();\n            }\n        };\n    }, []);\n};\nexport const useLayoutEffectOnce = (effect) => {\n    const effectFn = useRef(effect);\n    const destroyFn = useRef();\n    const effectCalled = useRef(false);\n    const rendered = useRef(false);\n    const [, setVal] = useState(0);\n    if (effectCalled.current) {\n        rendered.current = true;\n    }\n    useLayoutEffect(() => {\n        // only execute the effect first time around\n        if (!effectCalled.current) {\n            destroyFn.current = effectFn.current();\n            effectCalled.current = true;\n        }\n        // this forces one render after the effect is run\n        setVal((val) => val + 1);\n        return () => {\n            // if the comp didn't render since the useEffect was called,\n            // we know it's the dummy React cycle\n            if (!rendered.current) {\n                return;\n            }\n            // otherwise this is not a dummy destroy, so call the destroy func\n            if (destroyFn.current) {\n                destroyFn.current();\n            }\n        };\n    }, []);\n};\n"],"mappings":"AAAA;AACA,SAASA,SAAS,EAAEC,eAAe,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AACpE,OAAO,MAAMC,aAAa,GAAIC,MAAM,IAAK;EACrC,MAAMC,QAAQ,GAAGJ,MAAM,CAACG,MAAM,CAAC;EAC/B,MAAME,SAAS,GAAGL,MAAM,CAAC,CAAC;EAC1B,MAAMM,YAAY,GAAGN,MAAM,CAAC,KAAK,CAAC;EAClC,MAAMO,QAAQ,GAAGP,MAAM,CAAC,KAAK,CAAC;EAC9B,MAAM,GAAGQ,MAAM,CAAC,GAAGP,QAAQ,CAAC,CAAC,CAAC;EAC9B,IAAIK,YAAY,CAACG,OAAO,EAAE;IACtBF,QAAQ,CAACE,OAAO,GAAG,IAAI;EAC3B;EACAX,SAAS,CAAC,MAAM;IACZ;IACA,IAAI,CAACQ,YAAY,CAACG,OAAO,EAAE;MACvBJ,SAAS,CAACI,OAAO,GAAGL,QAAQ,CAACK,OAAO,CAAC,CAAC;MACtCH,YAAY,CAACG,OAAO,GAAG,IAAI;IAC/B;IACA;IACAD,MAAM,CAAEE,GAAG,IAAKA,GAAG,GAAG,CAAC,CAAC;IACxB,OAAO,MAAM;MACT;MACA;MACA,IAAI,CAACH,QAAQ,CAACE,OAAO,EAAE;QACnB;MACJ;MACA;MACA,IAAIJ,SAAS,CAACI,OAAO,EAAE;QACnBJ,SAAS,CAACI,OAAO,CAAC,CAAC;MACvB;IACJ,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;AACV,CAAC;AACD,OAAO,MAAME,mBAAmB,GAAIR,MAAM,IAAK;EAC3C,MAAMC,QAAQ,GAAGJ,MAAM,CAACG,MAAM,CAAC;EAC/B,MAAME,SAAS,GAAGL,MAAM,CAAC,CAAC;EAC1B,MAAMM,YAAY,GAAGN,MAAM,CAAC,KAAK,CAAC;EAClC,MAAMO,QAAQ,GAAGP,MAAM,CAAC,KAAK,CAAC;EAC9B,MAAM,GAAGQ,MAAM,CAAC,GAAGP,QAAQ,CAAC,CAAC,CAAC;EAC9B,IAAIK,YAAY,CAACG,OAAO,EAAE;IACtBF,QAAQ,CAACE,OAAO,GAAG,IAAI;EAC3B;EACAV,eAAe,CAAC,MAAM;IAClB;IACA,IAAI,CAACO,YAAY,CAACG,OAAO,EAAE;MACvBJ,SAAS,CAACI,OAAO,GAAGL,QAAQ,CAACK,OAAO,CAAC,CAAC;MACtCH,YAAY,CAACG,OAAO,GAAG,IAAI;IAC/B;IACA;IACAD,MAAM,CAAEE,GAAG,IAAKA,GAAG,GAAG,CAAC,CAAC;IACxB,OAAO,MAAM;MACT;MACA;MACA,IAAI,CAACH,QAAQ,CAACE,OAAO,EAAE;QACnB;MACJ;MACA;MACA,IAAIJ,SAAS,CAACI,OAAO,EAAE;QACnBJ,SAAS,CAACI,OAAO,CAAC,CAAC;MACvB;IACJ,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;AACV,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}