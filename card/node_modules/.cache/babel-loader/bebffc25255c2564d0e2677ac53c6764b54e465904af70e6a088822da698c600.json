{"ast":null,"code":"// ag-grid-react v30.0.4\nexport class LegacyPortalManager {\n  constructor(parent, wrappingElement, maxComponentCreationTimeMs) {\n    this.destroyed = false;\n    this.portals = [];\n    this.hasPendingPortalUpdate = false;\n    this.wrappingElement = wrappingElement ? wrappingElement : 'div';\n    this.parent = parent;\n    this.maxComponentCreationTimeMs = maxComponentCreationTimeMs ? maxComponentCreationTimeMs : LegacyPortalManager.MAX_COMPONENT_CREATION_TIME_IN_MS;\n  }\n  getPortals() {\n    return this.portals;\n  }\n  destroy() {\n    this.destroyed = true;\n  }\n  destroyPortal(portal) {\n    this.portals = this.portals.filter(curPortal => curPortal !== portal);\n    this.batchUpdate();\n  }\n  getComponentWrappingElement() {\n    return this.wrappingElement;\n  }\n  mountReactPortal(portal, reactComponent, resolve) {\n    this.portals = [...this.portals, portal];\n    this.waitForInstance(reactComponent, resolve);\n    this.batchUpdate();\n  }\n  updateReactPortal(oldPortal, newPortal) {\n    this.portals[this.portals.indexOf(oldPortal)] = newPortal;\n    this.batchUpdate();\n  }\n  batchUpdate() {\n    if (this.hasPendingPortalUpdate) {\n      return;\n    }\n    setTimeout(() => {\n      if (!this.destroyed) {\n        // destroyed?\n        this.parent.forceUpdate(() => {\n          this.hasPendingPortalUpdate = false;\n        });\n      }\n    });\n    this.hasPendingPortalUpdate = true;\n  }\n  waitForInstance(reactComponent, resolve) {\n    let startTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Date.now();\n    // if the grid has been destroyed in the meantime just resolve\n    if (this.destroyed) {\n      resolve(null);\n      return;\n    }\n    if (reactComponent.rendered()) {\n      resolve(reactComponent);\n    } else {\n      if (Date.now() - startTime >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate) {\n        // last check - we check if this is a null value being rendered - we do this last as using SSR to check the value\n        // can mess up contexts\n        if (reactComponent.isNullValue()) {\n          resolve(reactComponent);\n          return;\n        }\n        console.error(`AG Grid: React Component '${reactComponent.getReactComponentName()}' not created within ${this.maxComponentCreationTimeMs}ms`);\n        return;\n      }\n      window.setTimeout(() => {\n        this.waitForInstance(reactComponent, resolve, startTime);\n      });\n    }\n  }\n}\nLegacyPortalManager.MAX_COMPONENT_CREATION_TIME_IN_MS = 1000; // a second should be more than enough to instantiate a component\nexport class PortalManager {\n  constructor(refresher, wrappingElement, maxComponentCreationTimeMs) {\n    this.destroyed = false;\n    this.portals = [];\n    this.hasPendingPortalUpdate = false;\n    this.wrappingElement = wrappingElement ? wrappingElement : 'div';\n    this.refresher = refresher;\n    this.maxComponentCreationTimeMs = maxComponentCreationTimeMs ? maxComponentCreationTimeMs : PortalManager.MAX_COMPONENT_CREATION_TIME_IN_MS;\n  }\n  getPortals() {\n    return this.portals;\n  }\n  destroy() {\n    this.destroyed = true;\n  }\n  destroyPortal(portal) {\n    this.portals = this.portals.filter(curPortal => curPortal !== portal);\n    this.batchUpdate();\n  }\n  getComponentWrappingElement() {\n    return this.wrappingElement;\n  }\n  mountReactPortal(portal, reactComponent, resolve) {\n    this.portals = [...this.portals, portal];\n    this.waitForInstance(reactComponent, resolve);\n    this.batchUpdate();\n  }\n  updateReactPortal(oldPortal, newPortal) {\n    this.portals[this.portals.indexOf(oldPortal)] = newPortal;\n    this.batchUpdate();\n  }\n  batchUpdate() {\n    if (this.hasPendingPortalUpdate) {\n      return;\n    }\n    setTimeout(() => {\n      if (!this.destroyed) {\n        // destroyed?\n        this.refresher();\n        this.hasPendingPortalUpdate = false;\n      }\n    });\n    this.hasPendingPortalUpdate = true;\n  }\n  waitForInstance(reactComponent, resolve) {\n    let startTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Date.now();\n    // if the grid has been destroyed in the meantime just resolve\n    if (this.destroyed) {\n      resolve(null);\n      return;\n    }\n    if (reactComponent.rendered()) {\n      resolve(reactComponent);\n    } else {\n      if (Date.now() - startTime >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate) {\n        // last check - we check if this is a null value being rendered - we do this last as using SSR to check the value\n        // can mess up contexts\n        if (reactComponent.isNullValue()) {\n          resolve(reactComponent);\n          return;\n        }\n        console.error(`AG Grid: React Component '${reactComponent.getReactComponentName()}' not created within ${this.maxComponentCreationTimeMs}ms`);\n        return;\n      }\n      window.setTimeout(() => {\n        this.waitForInstance(reactComponent, resolve, startTime);\n      });\n    }\n  }\n}\nPortalManager.MAX_COMPONENT_CREATION_TIME_IN_MS = 1000; // a second should be more than enough to instantiate a component","map":{"version":3,"names":["LegacyPortalManager","constructor","parent","wrappingElement","maxComponentCreationTimeMs","destroyed","portals","hasPendingPortalUpdate","MAX_COMPONENT_CREATION_TIME_IN_MS","getPortals","destroy","destroyPortal","portal","filter","curPortal","batchUpdate","getComponentWrappingElement","mountReactPortal","reactComponent","resolve","waitForInstance","updateReactPortal","oldPortal","newPortal","indexOf","setTimeout","forceUpdate","startTime","arguments","length","undefined","Date","now","rendered","isNullValue","console","error","getReactComponentName","window","PortalManager","refresher"],"sources":["/home/vvdn/React-practice/hello/node_modules/ag-grid-react/lib/shared/portalManager.mjs"],"sourcesContent":["// ag-grid-react v30.0.4\nexport class LegacyPortalManager {\n    constructor(parent, wrappingElement, maxComponentCreationTimeMs) {\n        this.destroyed = false;\n        this.portals = [];\n        this.hasPendingPortalUpdate = false;\n        this.wrappingElement = wrappingElement ? wrappingElement : 'div';\n        this.parent = parent;\n        this.maxComponentCreationTimeMs = maxComponentCreationTimeMs ? maxComponentCreationTimeMs : LegacyPortalManager.MAX_COMPONENT_CREATION_TIME_IN_MS;\n    }\n    getPortals() {\n        return this.portals;\n    }\n    destroy() {\n        this.destroyed = true;\n    }\n    destroyPortal(portal) {\n        this.portals = this.portals.filter(curPortal => curPortal !== portal);\n        this.batchUpdate();\n    }\n    getComponentWrappingElement() {\n        return this.wrappingElement;\n    }\n    mountReactPortal(portal, reactComponent, resolve) {\n        this.portals = [...this.portals, portal];\n        this.waitForInstance(reactComponent, resolve);\n        this.batchUpdate();\n    }\n    updateReactPortal(oldPortal, newPortal) {\n        this.portals[this.portals.indexOf(oldPortal)] = newPortal;\n        this.batchUpdate();\n    }\n    batchUpdate() {\n        if (this.hasPendingPortalUpdate) {\n            return;\n        }\n        setTimeout(() => {\n            if (!this.destroyed) { // destroyed?\n                this.parent.forceUpdate(() => {\n                    this.hasPendingPortalUpdate = false;\n                });\n            }\n        });\n        this.hasPendingPortalUpdate = true;\n    }\n    waitForInstance(reactComponent, resolve, startTime = Date.now()) {\n        // if the grid has been destroyed in the meantime just resolve\n        if (this.destroyed) {\n            resolve(null);\n            return;\n        }\n        if (reactComponent.rendered()) {\n            resolve(reactComponent);\n        }\n        else {\n            if (Date.now() - startTime >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate) {\n                // last check - we check if this is a null value being rendered - we do this last as using SSR to check the value\n                // can mess up contexts\n                if (reactComponent.isNullValue()) {\n                    resolve(reactComponent);\n                    return;\n                }\n                console.error(`AG Grid: React Component '${reactComponent.getReactComponentName()}' not created within ${this.maxComponentCreationTimeMs}ms`);\n                return;\n            }\n            window.setTimeout(() => {\n                this.waitForInstance(reactComponent, resolve, startTime);\n            });\n        }\n    }\n}\nLegacyPortalManager.MAX_COMPONENT_CREATION_TIME_IN_MS = 1000; // a second should be more than enough to instantiate a component\nexport class PortalManager {\n    constructor(refresher, wrappingElement, maxComponentCreationTimeMs) {\n        this.destroyed = false;\n        this.portals = [];\n        this.hasPendingPortalUpdate = false;\n        this.wrappingElement = wrappingElement ? wrappingElement : 'div';\n        this.refresher = refresher;\n        this.maxComponentCreationTimeMs = maxComponentCreationTimeMs ? maxComponentCreationTimeMs : PortalManager.MAX_COMPONENT_CREATION_TIME_IN_MS;\n    }\n    getPortals() {\n        return this.portals;\n    }\n    destroy() {\n        this.destroyed = true;\n    }\n    destroyPortal(portal) {\n        this.portals = this.portals.filter(curPortal => curPortal !== portal);\n        this.batchUpdate();\n    }\n    getComponentWrappingElement() {\n        return this.wrappingElement;\n    }\n    mountReactPortal(portal, reactComponent, resolve) {\n        this.portals = [...this.portals, portal];\n        this.waitForInstance(reactComponent, resolve);\n        this.batchUpdate();\n    }\n    updateReactPortal(oldPortal, newPortal) {\n        this.portals[this.portals.indexOf(oldPortal)] = newPortal;\n        this.batchUpdate();\n    }\n    batchUpdate() {\n        if (this.hasPendingPortalUpdate) {\n            return;\n        }\n        setTimeout(() => {\n            if (!this.destroyed) { // destroyed?\n                this.refresher();\n                this.hasPendingPortalUpdate = false;\n            }\n        });\n        this.hasPendingPortalUpdate = true;\n    }\n    waitForInstance(reactComponent, resolve, startTime = Date.now()) {\n        // if the grid has been destroyed in the meantime just resolve\n        if (this.destroyed) {\n            resolve(null);\n            return;\n        }\n        if (reactComponent.rendered()) {\n            resolve(reactComponent);\n        }\n        else {\n            if (Date.now() - startTime >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate) {\n                // last check - we check if this is a null value being rendered - we do this last as using SSR to check the value\n                // can mess up contexts\n                if (reactComponent.isNullValue()) {\n                    resolve(reactComponent);\n                    return;\n                }\n                console.error(`AG Grid: React Component '${reactComponent.getReactComponentName()}' not created within ${this.maxComponentCreationTimeMs}ms`);\n                return;\n            }\n            window.setTimeout(() => {\n                this.waitForInstance(reactComponent, resolve, startTime);\n            });\n        }\n    }\n}\nPortalManager.MAX_COMPONENT_CREATION_TIME_IN_MS = 1000; // a second should be more than enough to instantiate a component\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}